{
  "version": 3,
  "sources": ["../src/config.ts", "../src/auth.ts", "../src/drive.ts", "../src/manifest.ts", "../src/app.ts"],
  "sourcesContent": ["export interface OAuthConfig {\n  clientId: string;\n  redirectUri: string;\n}\n\n// TODO: Replace the placeholder client ID before running the spike locally.\nexport const oauthConfig: OAuthConfig = {\n  clientId:\n    \"554015392094-jbp76oeeqr52d4ol8c261fg398cvecio.apps.googleusercontent.com\",\n  redirectUri: \"http://localhost:8081/callback.html\"\n};\n", "import { oauthConfig } from \"./config\";\n\n// Secretless browser auth for the spike: use Google Identity Services (GIS)\n// token client to obtain an access token directly, then call OIDC userinfo\n// to obtain the user's email.\n//\n// This keeps the spike as a pure static SPA (no embedded client secret).\n\nconst GIS_SCRIPT_SRC = \"https://accounts.google.com/gsi/client\";\nconst USERINFO_ENDPOINT = \"https://openidconnect.googleapis.com/v1/userinfo\";\n\nconst SCOPES = [\n  \"openid\",\n  \"email\",\n  \"profile\",\n  \"https://www.googleapis.com/auth/drive\"\n];\n\nexport interface AuthResponse {\n  accessToken: string;\n  expiresIn: number;\n  refreshToken?: string;\n  email?: string;\n}\n\ntype GisTokenResponse = {\n  access_token?: string;\n  expires_in?: number;\n  error?: string;\n  error_description?: string;\n};\n\ndeclare global {\n  interface Window {\n    google?: any;\n  }\n}\n\nfunction loadGisScriptOnce(): Promise<void> {\n  // Already loaded?\n  if (window.google?.accounts?.oauth2) return Promise.resolve();\n\n  // Already in-flight?\n  const existing = document.querySelector(`script[src=\"${GIS_SCRIPT_SRC}\"]`) as HTMLScriptElement | null;\n  if (existing) {\n    return new Promise<void>((resolve, reject) => {\n      existing.addEventListener(\"load\", () => resolve(), { once: true });\n      existing.addEventListener(\"error\", () => reject(new Error(\"Failed to load Google Identity Services script.\")), { once: true });\n    });\n  }\n\n  return new Promise<void>((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = GIS_SCRIPT_SRC;\n    script.async = true;\n    script.defer = true;\n    script.onload = () => resolve();\n    script.onerror = () => reject(new Error(\"Failed to load Google Identity Services script.\"));\n    document.head.appendChild(script);\n  });\n}\n\nasync function fetchUserEmail(accessToken: string): Promise<string | undefined> {\n  const res = await fetch(USERINFO_ENDPOINT, {\n    method: \"GET\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`\n    }\n  });\n\n  if (!res.ok) {\n    // Email is helpful but not strictly required for the spike to call Drive.\n    return undefined;\n  }\n\n  const data = (await res.json()) as { email?: string };\n  return data.email;\n}\n\n/**\n * Kept name for compatibility with the rest of the spike.\n *\n * Note: This is no longer an auth-code+PKCE exchange. It is a GIS token client flow\n * (public client, no secret). Long runs may require re-authentication when the\n * access token expires.\n */\nexport async function runPkceAuth(): Promise<AuthResponse> {\n  await loadGisScriptOnce();\n\n  const tokenClient = window.google.accounts.oauth2.initTokenClient({\n    client_id: oauthConfig.clientId,\n    scope: SCOPES.join(\" \"),\n    // callback is set per-request to avoid race conditions.\n    callback: () => {\n      // no-op\n    }\n  });\n\n  const token = await new Promise<GisTokenResponse>((resolve) => {\n    tokenClient.callback = (resp: GisTokenResponse) => resolve(resp);\n    // Force a consent prompt so we consistently get the scopes in early testing.\n    tokenClient.requestAccessToken({ prompt: \"consent\" });\n  });\n\n  if (token.error) {\n    const desc = token.error_description ? `: ${token.error_description}` : \"\";\n    throw new Error(`OAuth token request failed: ${token.error}${desc}`);\n  }\n\n  const accessToken = token.access_token;\n  const expiresIn = token.expires_in;\n\n  if (!accessToken || !expiresIn) {\n    throw new Error(\"OAuth token request returned no access_token/expires_in.\");\n  }\n\n  const email = await fetchUserEmail(accessToken);\n\n  return {\n    accessToken,\n    expiresIn,\n    email\n  };\n}\n", "export interface DriveHttpError {\n  status: number;\n  statusText: string;\n  url: string;\n  headers: Record<string, string>;\n  bodyText: string;\n  bodyJson?: unknown;\n  reason?: string;\n  message?: string;\n}\n\nexport interface FileMetadataSnapshot {\n  id: string;\n  name?: string;\n  mimeType?: string;\n  parents?: string[];\n  driveId?: string;\n  ownedByMe?: boolean;\n  owners?: Array<{ displayName?: string; emailAddress?: string; me?: boolean }>;\n  capabilities?: Record<string, unknown>;\n}\n\nexport interface MoveRequestInfo {\n  fileId: string;\n  destinationFolderId: string;\n  supportsAllDrives: boolean;\n  addParents: string;\n  removeParents?: string;\n}\n\nexport interface MoveDiagnostics {\n  request: MoveRequestInfo;\n  before: FileMetadataSnapshot;\n  after?: FileMetadataSnapshot;\n  error?: DriveHttpError;\n}\n\nexport interface MoveFileResult {\n  ok: true;\n  result: { id: string; name?: string; webViewLink?: string };\n  diagnostics: MoveDiagnostics;\n}\n\nexport interface MoveFileFailure {\n  ok: false;\n  diagnostics: MoveDiagnostics;\n}\n\nexport type MoveFileOutcome = MoveFileResult | MoveFileFailure;\n\nfunction headersToRecord(headers: Headers): Record<string, string> {\n  const out: Record<string, string> = {};\n  for (const [k, v] of headers.entries()) out[k] = v;\n  return out;\n}\n\nfunction tryParseJson(text: string): unknown | undefined {\n  try {\n    return JSON.parse(text) as unknown;\n  } catch {\n    return undefined;\n  }\n}\n\nfunction extractDriveReason(bodyJson: unknown): { reason?: string; message?: string } {\n  // Drive errors are typically: { error: { errors: [{ reason, message, ... }], message, ... } }\n  if (!bodyJson || typeof bodyJson !== \"object\") return {};\n  const anyJson = bodyJson as any;\n  const err = anyJson.error;\n  if (!err || typeof err !== \"object\") return {};\n  const topMessage = typeof err.message === \"string\" ? err.message : undefined;\n  const errors = Array.isArray(err.errors) ? err.errors : undefined;\n  const first = errors && errors.length > 0 ? errors[0] : undefined;\n  const reason = first && typeof first.reason === \"string\" ? first.reason : undefined;\n  const message = first && typeof first.message === \"string\" ? first.message : topMessage;\n  return { reason, message };\n}\n\nasync function fetchJsonWithHttp<T>(url: string, options: RequestInit): Promise<{ ok: true; json: T } | { ok: false; error: DriveHttpError }> {\n  const response = await fetch(url, options);\n  const bodyText = await response.text();\n  const headers = headersToRecord(response.headers);\n\n  if (!response.ok) {\n    const bodyJson = tryParseJson(bodyText);\n    const { reason, message } = extractDriveReason(bodyJson);\n    return {\n      ok: false,\n      error: {\n        status: response.status,\n        statusText: response.statusText,\n        url,\n        headers,\n        bodyText,\n        bodyJson,\n        reason,\n        message\n      }\n    };\n  }\n\n  const bodyJson = tryParseJson(bodyText);\n  return { ok: true, json: (bodyJson as T) ?? ({} as T) };\n}\n\nasync function getFileSnapshot(accessToken: string, fileId: string): Promise<FileMetadataSnapshot> {\n  const fields = [\n    \"id\",\n    \"name\",\n    \"mimeType\",\n    \"parents\",\n    \"driveId\",\n    \"ownedByMe\",\n    \"owners(displayName,emailAddress,me)\",\n    \"capabilities\"\n  ].join(\",\");\n\n  const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?fields=${encodeURIComponent(fields)}&supportsAllDrives=true`;\n  const res = await fetchJsonWithHttp<FileMetadataSnapshot>(url, {\n    method: \"GET\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`\n    }\n  });\n\n  if (!res.ok) {\n    // If we cannot read metadata, still return a minimal snapshot to avoid losing context.\n    return { id: fileId };\n  }\n\n  // Ensure the id is always present.\n  return { id: fileId, ...res.json };\n}\n\nexport async function moveFile(\n  accessToken: string,\n  fileId: string,\n  destinationFolderId: string\n): Promise<MoveFileOutcome> {\n  const before = await getFileSnapshot(accessToken, fileId);\n  const existingParents = before.parents ?? [];\n\n  const params = new URLSearchParams({\n    supportsAllDrives: \"true\",\n    addParents: destinationFolderId\n  });\n  // TODO: removeParents seem to be ignored when moving a file into a Shared Drive.\n  // Verify this observation when building the production version, and if so, document it.\n  if (existingParents.length > 0) {\n    params.set(\"removeParents\", existingParents.join(\",\"));\n  }\n\n  const request: MoveRequestInfo = {\n    fileId,\n    destinationFolderId,\n    supportsAllDrives: true,\n    addParents: destinationFolderId,\n    removeParents: existingParents.length > 0 ? existingParents.join(\",\") : undefined\n  };\n\n  const diagnostics: MoveDiagnostics = {\n    request,\n    before\n  };\n\n  const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?${params.toString()}`;\n  const patchRes = await fetchJsonWithHttp<{ id: string; name?: string; webViewLink?: string }>(url, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({})\n  });\n\n  if (!patchRes.ok) {\n    diagnostics.error = patchRes.error;\n    return { ok: false, diagnostics };\n  }\n\n  const after = await getFileSnapshot(accessToken, fileId);\n  diagnostics.after = after;\n\n  return {\n    ok: true,\n    result: patchRes.json,\n    diagnostics\n  };\n}\n", "export interface Manifest {\n  sourceFileId: string;\n  allowedUsers: Record<string, string>;\n}\n\n\n\n\n// Inline manifest for the spike. Update the values locally as needed.\nexport const manifest: Manifest = {\n  sourceFileId: \"1mEOEuuRGB7x7N1aU1GAHBmQzke_ww_GyyXpyYKNk4-Q\",\n  allowedUsers: {\n    \"nikander.pekka@gmail.com\": \"10Px9dQKe2WeBl1YGf1BHafs5C4MicfWq\"\n  }\n};\n\n// Inline manifest for the spike. Update the values locally as needed.\nexport const manifest1: Manifest = {\n  sourceFileId: \"1JUdNPV0SwdlQc0O-hrSvjnqRJQv78wJ07yGi0XroayI\",\n  allowedUsers: {\n    \"nikander.pekka@gmail.com\": \"10Px9dQKe2WeBl1YGf1BHafs5C4MicfWq\"\n  }\n};\n\n// Inline manifest for the spike. Update the values locally as needed.\nexport const manifest2: Manifest = {\n  sourceFileId: \"1EGF_usFIAUzWaVZVh9poCynU4W9wnng1WkbTigYIVyo\",\n  allowedUsers: {\n    \"pekkailmari@holotropic.fi\": \"10Px9dQKe2WeBl1YGf1BHafs5C4MicfWq\"\n  }\n};\n", "import { runPkceAuth } from \"./auth\";\nimport { moveFile, MoveFileOutcome } from \"./drive\";\nimport { manifest } from \"./manifest\";\n\nfunction setStatus(message: string): void {\n  const statusElement = document.getElementById(\"status\");\n  if (statusElement) {\n    statusElement.textContent = message;\n  }\n}\n\nfunction setJsonOutput(label: string, data: unknown): void {\n  const output = document.getElementById(\"result\");\n  if (!output) return;\n\n  const container = document.createElement(\"div\");\n  const title = document.createElement(\"h3\");\n  title.textContent = label;\n  const pre = document.createElement(\"pre\");\n  pre.textContent = JSON.stringify(data, null, 2);\n\n  container.appendChild(title);\n  container.appendChild(pre);\n  output.appendChild(container);\n}\n\nfunction clearOutput(): void {\n  const output = document.getElementById(\"result\");\n  if (output) output.innerHTML = \"\";\n}\n\nfunction summariseOutcome(outcome: MoveFileOutcome): string {\n  const d = outcome.diagnostics;\n  const beforeParents = d.before.parents?.length ?? 0;\n  const afterParents = d.after?.parents?.length;\n  const reason = d.error?.reason;\n  const msg = d.error?.message;\n  const status = d.error?.status;\n  return outcome.ok\n    ? `OK. beforeParents=${beforeParents}, afterParents=${afterParents ?? \"?\"}`\n    : `FAILED. http=${status ?? \"?\"}, reason=${reason ?? \"?\"}, message=${msg ?? \"(no message)\"}, beforeParents=${beforeParents}`;\n}\n\nasync function handleStart(button: HTMLButtonElement): Promise<void> {\n  button.disabled = true;\n  setStatus(\"Authorising with Google...\");\n\n  try {\n    const auth = await runPkceAuth();\n    if (!auth.email) {\n      throw new Error(\"Could not determine user email from the ID token.\");\n    }\n\n    const destinationFolder = manifest.allowedUsers[auth.email];\n    if (!destinationFolder) {\n      throw new Error(\n        `The manifest does not allow ${auth.email}. Update manifest.ts to add this user.`\n      );\n    }\n\n    clearOutput();\n    setStatus(\"Moving the test file into the Shared Drive...\");\n    const outcome = await moveFile(auth.accessToken, manifest.sourceFileId, destinationFolder);\n\n    setStatus(summariseOutcome(outcome));\n\n    setJsonOutput(\"Move diagnostics\", outcome.diagnostics);\n\n    if (outcome.ok) {\n      const result = outcome.result;\n      const output = document.getElementById(\"result\");\n      if (output) {\n        const details = document.createElement(\"div\");\n        details.textContent = `File now at ID: ${result.id}`;\n        output.appendChild(details);\n        if (result.webViewLink) {\n          const anchor = document.createElement(\"a\");\n          anchor.href = result.webViewLink;\n          anchor.target = \"_blank\";\n          anchor.rel = \"noreferrer\";\n          anchor.textContent = \"Open in Drive\";\n          output.appendChild(anchor);\n        }\n      }\n    } else {\n      // Also show a compact one-line error at the top.\n      const err = outcome.diagnostics.error;\n      if (err) {\n        setJsonOutput(\"Drive HTTP error (parsed)\", {\n          status: err.status,\n          statusText: err.statusText,\n          reason: err.reason,\n          message: err.message,\n          url: err.url\n        });\n      }\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    setStatus(`Error: ${message}`);\n  } finally {\n    button.disabled = false;\n  }\n}\n\nfunction init(): void {\n  const startButton = document.getElementById(\"start\");\n  if (!(startButton instanceof HTMLButtonElement)) {\n    setStatus(\"Start button not found in the document.\");\n    return;\n  }\n  startButton.addEventListener(\"click\", () => {\n    handleStart(startButton);\n  });\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", init);\n"],
  "mappings": "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",
  "names": ["bodyJson"]
}
