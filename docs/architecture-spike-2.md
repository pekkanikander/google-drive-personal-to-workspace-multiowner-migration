# Architecture spike 2 (Browser‑based user app)

## Background

Our Architecture spike 1 (see [architecture-spike.md]) partially succeeded and partialy failed.
It succeeded in the sense that we were able to verify that a user account could grant a server app,
running on the developer's localhost, the permission to copy a file from the private source tree
to the shared workspace tree.
However, it failed with the sense that as of late 2025, when a new Google Workspace for Nonprofits
organisation enables Google Cloud Projects, Google sets by default hardened security settings so that,
among other things, it is no longer possible for a Google Cloud Run to serve a user interface
impossible in practice, or at least impossible without changing the Google Cloud security settings
at the organisation level a lot.
We considered requiring such security settings changes as a potential no go for our target audience
(small non-profits and independent companies).

As a result, we had to abandon, at least temporarily, our original idea of using Cloud Runs
to serve the user interface to the users who own the original files.

As a result of that, we decided to pivot with the architecture and attempt a SPA based approach instead.
This second architecture spike defines such an approach.

## Goal

Verify that a **static, browser‑based single‑page application** (SPA) can:

1. Authenticate a personal Gmail user via OAuth 3LO in the browser.
2. Obtain an access token with appropriate Drive scopes.
3. Perform a `files.copy` (or `files.move` or `files.create` + upload) from the user’s **personal Google Drive** into a **designated subfolder** in a Workspace Shared Drive.
4. Rely solely on:
   - the user’s own OAuth token,
   - pre‑provisioned ACLs on the source and destination folders,
   - and a small manifest mapping `user_email → target_folder_id`, to be generated by admin‑side tools.
5. Run entirely from static hosting (Firebase Hosting, Cloud Storage website, GitHub Pages, etc.) without any backend involvement for the user‑facing flow.

This spike validates wheter a *cloud‑agnostic, user‑side architecture* works in practice, avoiding Cloud Run IAM issues that affected spike 1.

---

## Constraints and assumptions

- No backend API calls are made during the user workflow.
- No Cloud Run identity tokens or Workspace service accounts are used on the user side.
- The Shared Drive destination folder is initially empty or otherwise safe to expose with per-user Writer/Editor ACL.
- We do not check who owns the source file; whatever Drive allows with the user’s token is accepted.
- Workspace admins must explicitly grant each participating personal Gmail account editor access to the Shared Drive folder that this spike targets.
- A future admin‑side tool (Cloud Run or local) will:
  - enumerate the personal source Drive,
  - extract the list of participating Gmail accounts,
  - optionally create per‑user destination folders and ACLs,
  - generate the manifest (JSON?) used by the browser app.

This spike focuses only on the **user-facing browser component**.

---

## What success looks like

A developer can open the static SPA in their browser (served first locally and then from simple hosting), click “Start”, authenticate with OAuth, and see:

- The browser obtains a token for `user@gmail.com`.
- The SPA loads a manifest (hard‑coded for this spike).
- The SPA verifies the token email exists in the manifest.
- A `files.copy` / `file.move` / `file.create` call:
  - "reads" a fixed personal‑Drive file owned by the logged‑in user,
  - "writes" a new file inside the mapped Shared Drive folder,
  - receives a new file ID and displays success.

If all of this works without backend assistance, this piece of the proposed architecture is validated.

---

## Minimal implementation plan

### Language and overall structure

For this spike (and likely for production), use **TypeScript** compiled to plain JavaScript, with no framework and minimal tooling.
The aim is a small, functionally flavoured codebase that stays close to Google’s JS examples while retaining good type safety.

Suggested structure:

- `index.html`
  - Minimal HTML shell, contains the “Start migration” button and loads the compiled `app.js`.
- `src/app.ts`
  - Entry point; wires together auth, manifest lookup, and the copy operation.
- `src/auth.ts`
  - Encapsulates Google Identity Services / OAuth initialisation and token retrieval.
- `src/drive.ts`
  - Thin wrapper around the Drive REST API calls needed for the spike (primarily `files.copy`).
- `src/manifest.ts`
  - Provides the hard‑coded manifest mapping `user_email → target_folder_id` and the fixed `source_file_id`.

A simple build step (e.g. `tsc` or a small `esbuild` script) should emit a single `app.js` file consumed by `index.html`.
No bundler, router, or UI framework is needed for this spike.

### 1. Static hosting setup

For the spike:

- Use local static files (`index.html`, `app.js`).
- Later variants will deploy to Firebase Hosting and/or GitHub Pages.

During local testing we simply run a static HTTP server from the `public/` directory
(for example `python3 -m http.server 8081`) so the OAuth redirect origin matches `http://localhost:8081`.

No bundlers or UI frameworks are needed; a simple TS→JS compile step (producing a single `app.js`) is enough.

---

### 2. OAuth client setup

Create a new OAuth client (Web application) with initially:

- JavaScript origins:
  - `http://localhost:8081` (or any local port)
- Redirect URIs:
  - `http://localhost:8081/callback.html`

The spike **always** uses the OAuth authorization-code flow with PKCE via Google Identity Services (no implicit grant).
This keeps us aligned with Google’s current guidance and avoids future deprecations.
Only the browser participates; no backend exchange is available beyond the token request itself.

---

### 3. Minimal manifest

Hard-code a manifest object in TypeScript (for example in `src/manifest.ts`, compiled into `app.js`):

```json
{
  "allowed_users": {
    "example.user@gmail.com": "TARGET_FOLDER_ID"
  },
  "source_file_id": "SOURCE_FILE_ID"
}
```

No dynamic fetching; purely static. For this spike the manifest is bundled directly into the JavaScript bundle.

---

### 4. Minimal user workflow

1. User clicks “Start migration”.
2. JS triggers Google OAuth via the Google Identity Services OAuth2 code+PKCE helpers (no legacy `gapi.auth2` usage).
3. JS extracts the user’s email from the token.
4. JS checks:
   - Is `email` in `allowed_users`?
     If not → refuse.
5. JS calls:
   ```http
   POST https://www.googleapis.com/drive/v3/files/{sourceId}/copy
   ```
   with:
   ```json
   { "parents": ["TARGET_FOLDER_ID"] }
   ```
   and the user’s token as `Authorization: Bearer ...`.
6. On success:
   - Display new file ID and file name.
   - Optionally link to the newly copied file.

---

### 5. Handling scopes
Request:

```
https://www.googleapis.com/auth/drive
```

This matches spike 1 and keeps behaviour predictable.

The SPA should ignore unexpected scope permutations (order differences), just as spike 1 learned to do.

---

### 6. Expected difficulties (what we spike)

- Correctly initialising the Google JS OAuth library.
- Getting the token programmatically from the redirect.
- Confirming browser‑side Drive API calls are allowed with the token.
- Ensuring Drive ACLs allow the personal Gmail user to write to the Shared Drive folder.
  - We assume the organisation temporarily allows personal Gmail editors for the test folders and document this requirement.
- Ensuring CORS and fetch calls work cleanly from a static page.

This spike is not concerned with:

- folder enumeration,
- large batches of files,
- manifest generation,
- backend integration.

---

## Result and lessons (to be filled after spike)

Leave this section empty for now.
