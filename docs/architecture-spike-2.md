# Architecture spike 2 (Browser‑based user app)

## Background

Our Architecture spike 1 (see [architecture-spike.md]) partially succeeded and partialy failed.
It succeeded in the sense that we were able to verify that a user account could grant a server app,
running on the developer's localhost, the permission to copy a file from the private source tree
to the shared workspace tree.
However, it failed with the sense that as of late 2025, when a new Google Workspace for Nonprofits
organisation enables Google Cloud Projects, Google sets by default hardened security settings so that,
among other things, it is no longer possible for a Google Cloud Run to serve a user interface.
It is impossible without changing the Google Cloud security settings at the organisation level.
We considered requiring such security settings changes as a potential no go for our target audience
(small non-profits and independent companies).

As a result, we had to abandon, at least temporarily, our original idea of using Cloud Runs
to serve the user interface to the users who own the original files.

As a result of that, we decided to pivot with the architecture and attempt a SPA based approach instead.
This second architecture spike defines such an approach.

## Goal

Verify that a **static, browser‑based single‑page application** (SPA) can:

1. Authenticate a personal Gmail user via OAuth 3LO in the browser.
2. Obtain an access token with appropriate Drive scopes.
3. Perform a `files.copy` (or `files.move` or `files.create` + upload) from the user’s
   **personal Google Drive** into a **designated subfolder** in a Workspace Shared Drive.
4. Rely solely on:
   - the user’s own OAuth token,
   - pre‑provisioned ACLs on the source and destination folders,
   - and a small manifest mapping `user_email → target_folder_id`, to be generated by admin‑side tools.
5. Run entirely from static hosting (Firebase Hosting, Cloud Storage website, GitHub Pages, etc.)
   without any backend involvement for the user‑facing flow.

This spike validates wheter a *cloud‑agnostic, user‑side architecture* works in practice,
avoiding Cloud Run IAM issues that affected spike 1.

---

## Constraints and assumptions

- No backend API calls are made during the user workflow.
- No Cloud Run identity tokens or Workspace service accounts are used on the user side.
- The Shared Drive destination folder is initially empty or otherwise safe to expose with per-user Writer/Editor ACL.
- We do not check who owns the source file; whatever Drive allows with the user’s token is accepted.
- Workspace admins must explicitly grant each participating personal Gmail account editor access to the Shared Drive folder that this spike targets.
- A future admin‑side tool (Cloud Run or local) will:
  - enumerate the personal source Drive,
  - extract the list of participating Gmail accounts,
  - optionally create per‑user destination folders and ACLs,
  - generate the manifest (JSON?) used by the browser app.

This spike focuses only on the **user-facing browser component**.

---

## What success looks like

A developer can open the static SPA in their browser (served first locally and then from simple hosting), click “Start”, authenticate with OAuth, and see:

- The browser obtains a token for `user@gmail.com`.
- The SPA loads a manifest (hard‑coded for this spike).
- The SPA verifies the token email exists in the manifest.
- A Drive API call (move or copy):
  - "reads" a fixed personal-Drive file owned by the logged-in user,
  - moves or copies it into the mapped Shared Drive folder,
  - confirms completion (move keeps the original ID; copy yields a new ID).

If all of this works without backend assistance, this piece of the proposed architecture is validated.

---

## Minimal implementation plan

### Language and overall structure

For this spike (and likely for production), use **TypeScript** compiled to plain JavaScript, with no framework and minimal tooling.
The aim is a small, functionally flavoured codebase that stays close to Google’s JS examples while retaining good type safety.

Suggested structure:

- `index.html`
  - Minimal HTML shell, contains the “Start migration” button and loads the compiled `app.js`.
- `src/app.ts`
  - Entry point; wires together auth, manifest lookup, and the copy operation.
- `src/auth.ts`
  - Encapsulates Google Identity Services / OAuth initialisation and token retrieval.
- `src/drive.ts`
  - Thin wrapper around the Drive REST API calls needed for the spike (primarily `files.copy`).
- `src/manifest.ts`
  - Provides the hard‑coded manifest mapping `user_email → target_folder_id` and the fixed `source_file_id`.

A simple build step (e.g. `tsc` or a small `esbuild` script) should emit a single `app.js` file consumed by `index.html`.
No bundler, router, or UI framework is needed for this spike.

### 1. Static hosting setup

For the spike:

- Use local static files (`index.html`, `app.js`).
- Later variants will deploy to Firebase Hosting and/or GitHub Pages.

During local testing we simply run a static HTTP server from the `public/` directory
(for example `python3 -m http.server 8081`) so the OAuth redirect origin matches `http://localhost:8081`.

No bundlers or UI frameworks are needed; a simple TS→JS compile step (producing a single `app.js`) is enough.

---

### 2. OAuth client setup

Create a new OAuth client (Web application) with initially:

- JavaScript origins:
  - `http://localhost:8081` (or any local port)
- Redirect URIs:
  - `http://localhost:8081/callback.html`

Initial experiments used the OAuth authorization‑code flow with PKCE via Google Identity Services.
However, this required embedding a client secret at build time, which is incompatible with static hosting.

**Final Spike‑2 design:** the spike uses the Google Identity Services **token client** (public client, no redirect, no client secret).
The browser requests an access token directly and then calls the OpenID Connect `userinfo` endpoint to obtain the user’s email address.

This keeps the application fully static and deployable on GitHub Pages or similar hosting.
Trade‑off: no refresh token is available; long runs may require re‑authentication.

---

### 3. Minimal manifest

Hard-code a manifest object in TypeScript (for example in `src/manifest.ts`, compiled into `app.js`):

```json
{
  "allowed_users": {
    "example.user@gmail.com": "TARGET_FOLDER_ID"
  },
  "source_file_id": "SOURCE_FILE_ID"
}
```

No dynamic fetching; purely static. For this spike the manifest is bundled directly into the JavaScript bundle.

---

### 4. Minimal user workflow

1. User clicks “Start migration”.
2. JS triggers Google OAuth via the Google Identity Services **token client** (no redirect, no PKCE).
3. JS obtains an access token and queries the OpenID Connect `userinfo` endpoint to resolve the user’s email.
4. JS checks:
   - Is `email` in `allowed_users`?
     If not → refuse.
5. JS calls the Drive API using the user’s token:
   - Default variant (current spike): `PATCH https://www.googleapis.com/drive/v3/files/{sourceId}?supportsAllDrives=true&addParents=DEST&removeParents=SRC`
     with an empty JSON body to **move** the file.
   - Alternative experiments (future): `files.copy` or `files.create` for pure copy workflows.
6. On success:
   - Display new file ID and file name.
   - Optionally link to the newly moved file.

Implementation note (Dec 2025): the current spike uses `files.update` with `addParents`/`removeParents`
so the personal file is moved into the Shared Drive folder rather than copied.
The file keeps its ID because Drive moves preserve IDs; only its parents change.
This still relies entirely on the user’s OAuth token and the Drive ACLs configured by the admin.

---

### 5. Handling scopes
Request:

```
https://www.googleapis.com/auth/drive
```

This matches spike 1 and keeps behaviour predictable.

The SPA should ignore unexpected scope permutations (order differences), just as spike 1 learned to do.

---

### 6. Expected difficulties (what we spike)

- Correctly initialising the Google JS OAuth library.
- Correctly configuring authorised JavaScript origins for static hosting; OAuth client changes may take several minutes to propagate.
- Ensuring Drive ACLs allow the personal Gmail user to write to the Shared Drive folder.
  - We assume the organisation temporarily allows personal Gmail editors for the test folders and document this requirement.
- Ensuring CORS and fetch calls work cleanly from a static page.

This spike is not concerned with:

- folder enumeration,
- large batches of files,
- manifest generation,
- backend integration.

---

## Result and lessons (Dec 2025)

- **Secretless GIS token flow works in a pure SPA.**
  The initial auth‑code + PKCE approach required a client secret and was rejected for static hosting.
  Switching to the Google Identity Services token client (public client, no redirect, no secret)
  worked reliably from both localhost and hosted origins.
  Email resolution was done via the OpenID Connect `userinfo` endpoint.
- **Static hosting works.** Serving `public/` via `python3 -m http.server 8081` (or equivalent)
  is all that is needed to exercise the flow; no backend helpers were required.
- **Manifest-gated access behaves as expected.** The inline manifest check is trivial to bypass,
  so Drive ACLs remain the real guardrail. Both Workspace-managed Gmail accounts and
  unrelated personal Gmail accounts succeeded after being granted editor access to the destination folder.
- **Drive moves preserve file IDs.** Using `files.update` with `addParents`/`removeParents` successfully
  moved a file from a personal Drive into a Shared Drive while retaining the original file ID.
  This validates “move-first” as the default migration mode, keeping downstream links intact.
  - `removeParents` seem to be ignored** when moving a file into a Shared Drive.
    Verify this observation when building the production version, and if so, document it.
- **Moving requires the user to be the owner (or at least writer) of the source.**
  When the OAuth user was not the owner, Drive errors surfaced as expected.
  We intentionally do not pre-check ownership; Drive enforces it.
- **Drive UI moves can change ownership and break repeatability.**
  In testing, moving a file into the Shared Drive via the API succeeded,
  but moving the same file back to the source via the Drive UI could change the file’s owner.
  Subsequent API moves then failed with “admin has not granted permission” / Shared Drive move-in errors
  because the effective owner/role context had changed.  Treat ownership as potentially mutable.
- **Copy variants remain future work.** The current SPA is structured so we can later swap
  the transfer call (`files.copy`, `files.create`) to validate the “copy” modes without
  rewriting auth/manifest plumbing.
- **Static cloud hosting validated.**
  The spike was successfully deployed to static hosting (custom domain and GitHub‑compatible setup)
  and behaved identically to localhost.
  GitHub Pages refusing to host secret‑bearing artefacts acted as a useful safety net, forcing a correct OAuth design early.
- **Client‑secret red flag resolved.**
  Static hosting environments must not embed OAuth client secrets.
  This spike resolved the issue by switching to a public‑client GIS token flow,
  eliminating the need for secrets or redirect URIs.
  This design was considered suitable for volunteer admins deploying the tool temporarily.
- **OAuth configuration propagation delay.**
  Changes to OAuth client settings (especially authorised origins) may take several minutes to take effect.
  Transient `redirect_uri_mismatch` or similar errors can occur during this window and may resolve without code changes.

### Addition 2025-12-15

- Folders cannot be moved. They give teamDrivesFolderMoveInNotSupported error.
